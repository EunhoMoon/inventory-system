# 동시성 이슈 해결 방법

## Java Synchronized

- 단일 서버일 경우 동기화를 위해 synchronized를 사용할 수 있다.
- 멀티 서버일 경우 동일한 문제 발생

## Database Lock

### Pessimistic Lock

- 다른 트랜잭션에서 데이터에 접근하지 못하도록 락(lock)을 걸어두는 방식
- 데이터 무결성을 보장하기 위해 사용(정산, 결제 등)
- 구현 방법이 단순하며, 트랜잭션간 충돌을 확실히 방지할 수 있다.
- 락이 설정된 동안 다른 트랜잭션은 대기하게 되므로 성능이 저하될 수 있다.
- 여러 트랜잭션이 동시에 락을 획득하려고 할 때 데드락이 발생할 수 있다.

### Optimistic Lock

- 데이터의 충돌이 발생할 가능성이 낮은 경우 사용(읽기가 많은 경우)
- 데이터를 읽을 때 버전 정보를 함께 읽어 충돌을 검증한다.
- 락을 걸지 않기 때문에 성능이 향상된다.
- 데이터 충돌시 재시도를 위한 로직을 직접 구현해야 하며, 충돌이 잦은 경우 성능이 저하될 수 있다.

### Named Lock

- 데이터베이스에서 특정 이름을 기반으로 락을 걸 걸어두는 방식
- 테이블이 아닌 이름을 기반으로 락을 걸기 때문에 데이터베이스 수준의 충돌을 방지할 수 있다.
- 락이 명시적으로 설정되고 해제되기 때문에 락을 해제하지 않을 경우 데드락이 발생할 수 있다.

## Redis Lock

### Lettuce

- Redis의 `setnx` 명령어를 사용하여 락을 걸어두는 방식
- 락을 획득하기 위해 반복적으로 요청을 보내는 Spin Lock
- 가벼운 클라이언트와 높은 성능을 제공한다.
- 락을 획득하기 까지 반복적으로 요청을 보내야 하기 때문에 Redis에 부하를 줄 수 있다.

### Redisson

- Pub/Sub 기능을 사용하여 락을 걸어두는 방식
- 고수준 API를 제공하여 락을 쉽게 사용할 수 있다.
- 락 만료, 자동 해제 등 다양한 기능을 제공한다.
- 외부 라이브러리를 사용하기 때문에 비용이 증가할 수 있다.